import fs from 'fs';
import path from 'path';
import chai from 'chai';
import { Lexer, IDS } from '../../src/lexer';

describe('Lexer Keywords', () => {
  const data = fs.readFileSync(path.resolve(__dirname, 'data', 'keywords.tokens'), { encoding: 'utf-8' });
  const lexer = new Lexer(data);
  const tokens = lexer.tokens();
  it('should generate 194 tokens', () => {
    chai.expect(tokens.length).to.eq(195);
  });
  const expect = [
    IDS.LUI,
    IDS.AUIPC,
    IDS.JAL,
    IDS.JALR,
    IDS.BEQ,
    IDS.BNE,
    IDS.BLT,
    IDS.BGE,
    IDS.BLTU,
    IDS.BGEU,
    IDS.LB,
    IDS.LH,
    IDS.LW,
    IDS.LBU,
    IDS.LHU,
    IDS.SB,
    IDS.SH,
    IDS.SW,
    IDS.ADDI,
    IDS.SLTI,
    IDS.SLTIU,
    IDS.XORI,
    IDS.ORI,
    IDS.ANDI,
    IDS.SLLI,
    IDS.SRLI,
    IDS.SRAI,
    IDS.ADD,
    IDS.SUB,
    IDS.SLL,
    IDS.SLT,
    IDS.SLTU,
    IDS.XOR,
    IDS.SRL,
    IDS.SRA,
    IDS.OR,
    IDS.AND,
    IDS.FENCE,
    IDS.ECALL,
    IDS.EBREAK,
    IDS.FENCEI,
    IDS.CSRRW,
    IDS.CSRRS,
    IDS.CSRRC,
    IDS.CSRRWI,
    IDS.CSRRSI,
    IDS.CSRRCI,
    IDS.MUL,
    IDS.MULH,
    IDS.MULHSU,
    IDS.MULHU,
    IDS.DIV,
    IDS.DIVU,
    IDS.REM,
    IDS.REMU,
    IDS.LRW,
    IDS.SCW,
    IDS.AMOSWAPW,
    IDS.AMOADDW,
    IDS.AMOXORW,
    IDS.AMOANDW,
    IDS.AMOORW,
    IDS.AMOMINW,
    IDS.AMOMAXW,
    IDS.AMOMINUW,
    IDS.AMOMAXUW,
    IDS.FLW,
    IDS.FSW,
    IDS.FMADDS,
    IDS.FMSUBS,
    IDS.FNMSUBS,
    IDS.FNMADDS,
    IDS.FADDS,
    IDS.FSUBS,
    IDS.FMULS,
    IDS.FDIVS,
    IDS.FSQRTS,
    IDS.FSGNJS,
    IDS.FSGNJNS,
    IDS.FSGNJXS,
    IDS.FMINS,
    IDS.FMAXS,
    IDS.FCVTWS,
    IDS.FCVTWUS,
    IDS.FMVXW,
    IDS.FEQS,
    IDS.FLTS,
    IDS.FLES,
    IDS.FCLASSS,
    IDS.FCVTSW,
    IDS.FCVTSWU,
    IDS.FMVWX,
    IDS.FLD,
    IDS.FSD,
    IDS.FMADDD,
    IDS.FMSUBD,
    IDS.FNMSUBD,
    IDS.FNMADDD,
    IDS.FADDD,
    IDS.FSUBD,
    IDS.FMULD,
    IDS.FDIVD,
    IDS.FSQRTD,
    IDS.FSGNJD,
    IDS.FSGNJND,
    IDS.FSGNJXD,
    IDS.FMIND,
    IDS.FMAXD,
    IDS.FCVTSD,
    IDS.FCVTDS,
    IDS.FEQD,
    IDS.FLTD,
    IDS.FLED,
    IDS.FCLASSD,
    IDS.FCVTWD,
    IDS.FCVTWUD,
    IDS.FCVTDW,
    IDS.FCVTDWU,
    IDS.LA,
    IDS.LLA,
    IDS.NOP,
    IDS.LI,
    IDS.MV,
    IDS.NOT,
    IDS.NEG,
    IDS.SEQZ,
    IDS.SNEZ,
    IDS.SLTZ,
    IDS.SGTZ,
    IDS.BEQZ,
    IDS.BNEZ,
    IDS.BLEZ,
    IDS.BGEZ,
    IDS.BLTZ,
    IDS.BGTZ,
    IDS.BGT,
    IDS.BLE,
    IDS.BGTU,
    IDS.BLEU,
    IDS.J,
    IDS.JR,
    IDS.RET,
    IDS.CALL,
    IDS.TAIL,
    IDS.RDINSTRET,
    IDS.RDCYCLE,
    IDS.RDTIME,
    IDS.CSRR,
    IDS.CSRW,
    IDS.CSRS,
    IDS.CSRC,
    IDS.CSRWI,
    IDS.CSRSI,
    IDS.CSRCI,
    IDS.FRCSR,
    IDS.FSCSR,
    IDS.FRRM,
    IDS.FSRM,
    IDS.FRFLAGS,
    IDS.FSFLAGS,
    IDS.FMVS,
    IDS.FABSS,
    IDS.FNEGS,
    IDS.FMVD,
    IDS.FNEGD,
    IDS.FABSD,
    IDS.D_BYTE,
    IDS.D_HALF,
    IDS.D_HALF,
    IDS.D_HALF,
    IDS.D_WORD,
    IDS.D_WORD,
    IDS.D_WORD,
    IDS.D_FLOAT,
    IDS.D_ASCII,
    IDS.D_STRING,
    IDS.D_STRING,
    IDS.D_STRING,
    IDS.D_ZERO,
    IDS.D_ZERO,
    IDS.D_SECTION,
    IDS.D_BSS,
    IDS.D_RODATA,
    IDS.D_DATA,
    IDS.D_TEXT,
    IDS.D_GLOBL,
    IDS.D_GLOBL,
    IDS.D_ALIGN,
    IDS.D_ALIGN,
    IDS.D_BALIGN,
    IDS.D_FILE,
    IDS.D_EQU,
    IDS.D_EQU,
    IDS.EOL,
    IDS.EOF
  ];
  tokens.forEach((e, i) => {
    it(`id should be ${expect[i]}`, () => {
      chai.expect(e.id).to.eq(expect[i]);
    });
  });
});
